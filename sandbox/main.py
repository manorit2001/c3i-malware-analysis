import click
import subprocess
import logging
from pathlib import Path
import configparser
import shutil
import traceback
import os


def try_run(
    list_args: list, msg: str, reraise=True, level=logging.DEBUG, **kwargs
) -> subprocess.CompletedProcess:
    """
    Runs subprocess.run in a try except with some default arguments ( which can be overriden by supplying kwargs )
            Parameters:
                    list_args (list): Subprocess list which will be passed to subprocess.run
                    msg (str): A meaningful error message to be raised during non-zero exit code
                    reraise (bool):
                        True: will raise an Exception with traceback on error
                        False: will log a warning on error
                    **kwargs: additional parameters to be passed to subprocess.run
            Defaults:
                    subprocess.run is called with the following arguments by default
                    stderr = subprocess.PIPE
                    stdout = subprocess.PIPE # to print to console, pass kwargs ( stdout = None )
                    check = True
            Returns:
                    sub (subprocess.CompletedProcess): Object with the completed process
                        or
                    None: if the subprocess failed and reraise=False
    """

    cur_level = logging.getLogger().getEffectiveLevel()
    if level > cur_level:
        logging.getLogger().setLevel(level)

    try:
        kwargs["stdout"]
    except KeyError:
        kwargs["stdout"] = subprocess.PIPE

    if kwargs.get("stderr") is None:
        kwargs["stderr"] = subprocess.PIPE
    if kwargs.get("check") is None:
        kwargs["check"] = True

    list_args = [str(i) if isinstance(i, Path) else i for i in list_args]

    sub = None
    try:
        sub = subprocess.run(list_args, **kwargs)
    except (FileNotFoundError, TypeError) as e:
        logging.debug("arguments to subprocess")
        logging.debug(list_args)
        logging.debug(msg)
        logging.debug(kwargs)
        raise Exception("Command not found") from e
    except subprocess.CalledProcessError as e:
        logging.debug("stdout: \n{}".format(e.stdout.decode()))
        logging.debug("stderr: \n{}".format(e.stderr.decode()))
        logging.debug("returncode: {}".format(e.returncode))
        if reraise:
            raise Exception(msg) from e
        else:
            logging.warning(msg)
            logging.debug(traceback.format_exc())

    logging.getLogger().setLevel(cur_level)
    return sub


def get_cmd(args):
    cmd = ["vmrun", "-T", "ws"]
    cmd += args
    cmd += ["nogui"]
    logging.debug(cmd)
    return cmd


@click.command(help="create the snapshot of VM")
@click.argument("vmx_path", type=click.Path(exists=True))
def snapshot(vmx_path):
    config = configparser.ConfigParser()
    config.read("config.ini")

    sandbox_vm_dir = Path(config["default"]["work_dir"]) / "sandboxVM"

    try:
        # remove existing files
        shutil.rmtree(sandbox_vm_dir)
    except FileNotFoundError:
        pass

    sandbox_vm_dir.mkdir(parents=True, exist_ok=True)

    logging.info("Deleting previous snapshot")
    cmd = get_cmd(["deleteSnapshot", vmx_path, "InitSnapshot"])
    try_run(cmd, "Could not delete previous snapshot", reraise=False)

    logging.info("Suspending VM")
    cmd = get_cmd(["suspend", vmx_path, "soft"])
    try_run(cmd, "Could not suspend VM")

    vmx = Path(vmx_path).absolute().resolve()
    dirname = vmx.parents[0]
    vmss = next(
        (i for i in os.listdir(dirname) if i.endswith(".vmss")), None
    )  # find the suspended state file
    vmem = next(
        (i for i in os.listdir(dirname) if i.endswith(".vmem")), None
    )  # find the suspended state file

    shutil.move(dirname / vmss , sandbox_vm_dir / "backup.vmss")
    shutil.move(dirname / vmem , sandbox_vm_dir / "backup.vmem")

    logging.info("Creating snapshot...")
    cmd = get_cmd(["snapshot", vmx_path, "InitSnapshot"])
    try_run(cmd, "Could not create snapshot")

    shutil.copy(sandbox_vm_dir / "backup.vmss", dirname / vmss)
    shutil.copy(sandbox_vm_dir / "backup.vmem", dirname / vmem)

    logging.info("Snapshot successful, you can use restore now")


@click.command(help="will make a destroyable copy of VM")
@click.argument("vmx_path", type=click.Path(exists=True))
def restore(vmx_path):
    config = configparser.ConfigParser()
    config.read("config.ini")

    sandbox_vm_dir = Path(config["default"]["work_dir"]) / "sandboxVM"
    vm_dir = sandbox_vm_dir / "clonedVM"
    dest_vmx_path = vm_dir / "clonedVM.vmx"

    logging.info("Destroying previous instance")
    cmd = get_cmd(
        [
            "stop",
            dest_vmx_path,
            "hard"
        ]
    )
    try_run(cmd, "Could not stop previous instance", reraise=False)

    try:
        shutil.rmtree(vm_dir)
    except FileNotFoundError:
        pass
    finally:
        vm_dir.mkdir(exist_ok=True)

    logging.info("Cloning VM")
    cmd = get_cmd(
        [
            "clone",
            vmx_path,
            dest_vmx_path,
            "linked",
            "-snapshot=InitSnapshot",
            "-cloneName=sandboxVM",
        ]
    )

    try_run(cmd, "Could not create a linked clone for analysis")
    logging.info("sandboxVM clone created")

    logging.info("Copying suspended state")
    shutil.copy(sandbox_vm_dir / "backup.vmss", vm_dir / "clonedVM.vmss")
    shutil.copy(sandbox_vm_dir / "backup.vmem", vm_dir / "clonedVM.vmem")
    logging.info("Done")

    with open(dest_vmx_path, 'a') as f:
        f.write("checkpoint.vmState = \"clonedVM.vmss\"")

    # logging.info("Starting VM")
    # cmd = get_cmd(["start", dest_vmx_path])
    # try_run(cmd, "Could not start VM")


@click.group()
def main():
    logging.basicConfig(
        level=logging.DEBUG,
        format="[%(asctime)s][%(levelname)s] %(message)s",
        handlers=[logging.StreamHandler()],
    )


main.add_command(snapshot)
main.add_command(restore)

if __name__ == "__main__":
    main()
