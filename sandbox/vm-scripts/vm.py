import logging
import subprocess
import traceback
from pathlib import Path
from time import sleep

import click


def try_run(
    list_args: list, msg: str, reraise=True, level=logging.DEBUG, **kwargs
) -> subprocess.CompletedProcess:
    """
    Runs subprocess.run in a try except with some default arguments ( which can be overriden by supplying kwargs )
            Parameters:
                    list_args (list): Subprocess list which will be passed to subprocess.run
                    msg (str): A meaningful error message to be raised during non-zero exit code
                    reraise (bool):
                        True: will raise an Exception with traceback on error
                        False: will log a warning on error
                    **kwargs: additional parameters to be passed to subprocess.run
            Defaults:
                    subprocess.run is called with the following arguments by default
                    stderr = subprocess.PIPE
                    stdout = subprocess.PIPE # to print to console, pass kwargs ( stdout = None )
                    check = True
            Returns:
                    sub (subprocess.CompletedProcess): Object with the completed process
                        or
                    None: if the subprocess failed and reraise=False
    """

    cur_level = logging.getLogger().getEffectiveLevel()
    if level > cur_level:
        logging.getLogger().setLevel(level)

    try:
        kwargs["stdout"]
    except KeyError:
        kwargs["stdout"] = subprocess.PIPE

    if kwargs.get("stderr") is None:
        kwargs["stderr"] = subprocess.PIPE
    if kwargs.get("check") is None:
        kwargs["check"] = True

    list_args = [str(i) if isinstance(i, Path) else i for i in list_args]

    sub = None
    try:
        sub = subprocess.run(list_args, **kwargs)
    except (FileNotFoundError, TypeError) as e:
        logging.debug("arguments to subprocess")
        logging.debug(list_args)
        logging.debug(msg)
        logging.debug(kwargs)
        raise Exception("Command not found") from e
    except subprocess.CalledProcessError as e:
        logging.debug("stdout: \n{}".format(e.stdout.decode()))
        logging.debug("stderr: \n{}".format(e.stderr.decode()))
        logging.debug("returncode: {}".format(e.returncode))
        if reraise:
            raise Exception(msg) from e
        else:
            logging.warning(msg)
            logging.debug(traceback.format_exc())

    logging.getLogger().setLevel(cur_level)
    return sub


def get_cmd(args):
    cmd = ["vmrun", "-T", "ws"]
    cmd += args
    cmd += ["nogui"]
    logging.debug(cmd)
    return cmd


@click.command(help="create the snapshot of VM")
@click.argument("vmx_path", type=click.Path(exists=True))
def snapshot(vmx_path):
    logging.info("Deleting previous snapshot")
    cmd = get_cmd(["deleteSnapshot", vmx_path, "InitSnapshot"])
    try_run(cmd, "Could not delete previous snapshot", reraise=False)

    logging.info("Suspending VM")
    cmd = get_cmd(["suspend", vmx_path, "soft"])
    try_run(cmd, "Could not suspend VM")

    logging.info("Creating snapshot...")
    cmd = get_cmd(["snapshot", vmx_path, "InitSnapshot"])
    try_run(cmd, "Could not create snapshot")

    logging.info("Snapshot successful, you can use restore now")


@click.command(help="will make a destroyable copy of VM")
@click.argument("vmx_path", type=click.Path(exists=True))
def restore(vmx_path):
    logging.info("Destroying previous instance")
    cmd = get_cmd(["stop", vmx_path, "hard"])
    try_run(cmd, "Could not stop previous instance", reraise=False)
    sleep(3)

    logging.info("reverting VM")
    cmd = get_cmd(
        [
            "revertToSnapshot",
            vmx_path,
            "InitSnapshot",
        ]
    )

    try_run(cmd, "Could not revert VM")
    logging.info("Done")

    sleep(3)

    logging.info("Starting VM")
    cmd = get_cmd(["start", vmx_path])
    try_run(cmd, "Could not start VM")


@click.group()
def main():
    logging.basicConfig(
        level=logging.DEBUG,
        format="[%(asctime)s][%(levelname)s] %(message)s",
        handlers=[logging.StreamHandler()],
    )


main.add_command(snapshot)
main.add_command(restore)

if __name__ == "__main__":
    main()
