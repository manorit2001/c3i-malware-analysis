from pathlib import Path

import pefile
import peutils

DEFAULT_CONFIG = {
    "LowImportThreshold": 10,
    "NonStandardSectionThreshold": 3,
    "BadSectionNameThreshold": 2,
    "OnlyPEIDEntryPointSignatures": True,
    # large database has more than 3x as many signatures, but many are for non-packers
    # and will create false positives. we can move signatures from the long list to the short
    # list as needed, though.
    "UseLargePEIDDatabase": True,
    "CheckForPEIDSignatures": True,
    "CheckForBadEntryPointSections": True,
    "CheckForLowImportCount": True,
    "CheckForPackerSections": True,
    "CheckForNonStandardSections": True,
}


class PackerDetection:
    def __init__(self, file, report, deps_dir, config=DEFAULT_CONFIG):
        self.config = config
        self.report = report
        self.deps_dir = Path(deps_dir)
        self.pe = pefile.PE(file)
        self.packerSectionNames = {
            ".aspack": "Aspack packer",
            ".adata": "Aspack packer/Armadillo packer",
            "ASPack": "Aspack packer",
            ".ASPack": "ASPAck Protector",
            ".boom": "The Boomerang List Builder (config+exe xored with a single byte key 0x77)",
            ".ccg": "CCG Packer (Chinese Packer)",
            ".charmve": "Added by the PIN tool",
            "BitArts": "Crunch 2.0 Packer",
            "DAStub": "DAStub Dragon Armor protector",
            "!EPack": "Epack packer",
            "FSG!": "FSG packer (not a section name, but a good identifier)",
            ".gentee": "Gentee installer",
            "kkrunchy": "kkrunchy Packer",
            ".mackt": "ImpRec-created section",
            ".MaskPE": "MaskPE Packer",
            "MEW": "MEW packer",
            ".MPRESS1": "Mpress Packer",
            ".MPRESS2": "Mpress Packer",
            ".neolite": "Neolite Packer",
            ".neolit": "Neolite Packer",
            ".nsp1": "NsPack packer",
            ".nsp0": "NsPack packer",
            ".nsp2": "NsPack packer",
            "nsp1": "NsPack packer",
            "nsp0": "NsPack packer",
            "nsp2": "NsPack packer",
            ".packed": "RLPack Packer (first section)",
            "pebundle": "PEBundle Packer",
            "PEBundle": "PEBundle Packer",
            "PEC2TO": "PECompact packer",
            "PECompact2": "PECompact packer (not a section name, but a good identifier)",
            "PEC2": "PECompact packer",
            "pec1": "PECompact packer",
            "pec2": "PECompact packer",
            "PEC2MO": "PECompact packer",
            "PELOCKnt": "PELock Protector",
            ".perplex": "Perplex PE-Protector",
            "PESHiELD": "PEShield Packer",
            ".petite": "Petite Packer",
            ".pinclie": "Added by the PIN tool",
            "ProCrypt": "ProCrypt Packer",
            ".RLPack": "RLPack Packer (second section)",
            ".rmnet": "Ramnit virus marker",
            "RCryptor": "RPCrypt Packer",
            ".RPCrypt": "RPCrypt Packer",
            ".seau": "SeauSFX Packer",
            ".sforce3": "StarForce Protection",
            ".spack": "Simple Pack (by bagie)",
            ".svkp": "SVKP packer",
            "Themida": "Themida Packer",
            ".Themida": "Themida Packer",
            ".taz": "Some version os PESpin",
            ".tsuarch": "TSULoader",
            ".tsustub": "TSULoader",
            ".packed": "Unknown Packer",
            "PEPACK!!": "Pepack",
            ".Upack": "Upack packer",
            ".ByDwing": "Upack Packer",
            "UPX0": "UPX packer",
            "UPX1": "UPX packer",
            "UPX2": "UPX packer",
            "UPX!": "UPX packer",
            ".UPX0": "UPX Packer",
            ".UPX1": "UPX Packer",
            ".UPX2": "UPX Packer",
            ".vmp0": "VMProtect packer",
            ".vmp1": "VMProtect packer",
            ".vmp2": "VMProtect packer",
            "VProtect": "Vprotect Packer",
            ".winapi": "Added by API Override tool",
            "WinLicen": "WinLicense (Themida) Protector",
            "_winzip_": "WinZip Self-Extractor",
            ".WWPACK": "WWPACK Packer",
            ".yP": "Y0da Protector",
            ".y0da": "Y0da Protector",
        }
        self.knownSectionNames = [
            ".00cfg",
            ".arch",
            ".autoload_text",
            ".bindat",
            ".bootdat",
            ".bss",
            ".BSS",
            ".buildid",
            ".CLR_UEF",
            ".code",
            ".cormeta",
            ".complua",
            ".CRT",
            ".cygwin_dll_common",
            ".data",
            ".DATA",
            ".data1",
            ".data2",
            ".data3",
            ".debug",
            ".debug$F",
            ".debug$P",
            ".debug$S",
            ".debug$T",
            ".drectve ",
            ".didat",
            ".didata",
            ".edata",
            ".eh_fram",
            ".export",
            ".fasm",
            ".flat",
            ".gfids",
            ".giats",
            ".gljmp",
            ".glue_7t",
            ".glue_7",
            ".idata",
            ".idlsym",
            ".impdata",
            ".itext",
            ".ndata",
            ".orpc",
            ".pdata",
            ".rdata",
            ".reloc",
            ".rodata",
            ".rsrc",
            ".sbss",
            ".script",
            ".shared",
            ".sdata",
            ".srdata",
            ".stab",
            ".stabstr",
            ".sxdata",
            ".text",
            ".text0",
            ".text1",
            ".text2",
            ".text3",
            ".textbss",
            ".tls",
            ".tls$",
            ".udata",
            ".vsdata",
            ".xdata",
            ".wixburn",
            ".wpp_sf ",
            "BSS",
            "CODE",
            "DATA",
            "DGROUP",
            "edata",
            "idata",
            "INIT",
            "minATL",
            "PAGE",
            "rdata",
            "sdata",
            "shared",
            "Shared",
            "testdata",
            "text",
            "nv_fatb",
            "nv_FatBi",
        ]
        self.acceptableEntrySections = [".text"]
        self.alternativeEntrySections = [
            ".code",
            "text",
            ".text0",
            ".text1",
            ".text2",
            ".text3",
        ]
        self.driverEntrySection = ["INIT"]
        self.delphiBssSections = [".BSS", "BSS", ".bss"]
        self.delphiEntrySections = [".itext", "CODE"]
        if self.config["UseLargePEIDDatabase"]:
            self.signatures = peutils.SignatureDatabase(
                str(self.deps_dir / "peid/signatures_long.txt")
            )
        else:
            self.signatures = peutils.SignatureDatabase(
                str(self.deps_dir / "peid/signatures_short.txt")
            )

    def _FormatStringList(self, strlist):
        return "'%s'" % "', '".join(strlist)

    def _DoListsIntersect(self, l1, l2):
        return len(set(l1) & set(l2)) != 0

    def _GetCleanStringFromBytes(self, bbytes):
        return bbytes.decode("ascii").strip().rstrip("\0")

    def _GetCleanSectionName(self, section):
        return self._GetCleanStringFromBytes(section.Name)

    def PEIDetector(self):
        if not self.config["CheckForPEIDSignatures"]:
            return

        matches = self.signatures.match_all(
            self.pe, ep_only=self.config["OnlyPEIDEntryPointSignatures"]
        )
        if not matches:
            return
        for match in matches:
            self.report.IndicateDetection("Found PEID signature: %s" % match)

    def PackerSectionNameDetector(self):  # TODO test
        if not self.config["CheckForPackerSections"]:
            return
        for section in self.pe.sections:
            try:
                secName = self._GetCleanSectionName(section)
                if secName in self.packerSectionNames:
                    self.report.IndicateDetection(
                        "Section name '%s' matches known packer: [%s]"
                        % (secName, self.packerSectionNames[secName])
                    )
            except UnicodeDecodeError:
                self.report.IndicateSuspicion("Section name with invalid characters")

    def LowImportCountDetector(self):  # TODO test
        if not self.config["CheckForLowImportCount"]:
            return
        try:
            importCount = 0
            for library in self.pe.DIRECTORY_ENTRY_IMPORT:
                if (library.dll).lower() == b"mscoree.dll":
                    return  # .NET assembly, counting imports is misleading as they will have a low number
                importCount += len(library.imports)
            if importCount <= self.config["LowImportThreshold"]:
                self.report.IndicateDetection(
                    "Too few imports (total: %d)" % importCount
                )
        except AttributeError:
            pass

    def NonStandardSectionNameDetector(self):  # TODO test
        if not self.config["CheckForNonStandardSections"]:
            return
        unknownSections = []
        badSectionNameCount = 0
        for section in self.pe.sections:
            try:
                secName = self._GetCleanSectionName(section)
                if secName not in self.knownSectionNames:
                    unknownSections.append(secName)
            except UnicodeDecodeError:
                badSectionNameCount += 1
                self.report.IndicateSuspicion("Section name with invalid characters")

        unknownSectionCount = len(unknownSections)
        if unknownSectionCount >= self.config["NonStandardSectionThreshold"]:
            self.report.IndicateDetection(
                "Detected %d non-standard sections: %s"
                % (unknownSectionCount, self._FormatStringList(unknownSections))
            )
        if badSectionNameCount >= self.config["BadSectionNameThreshold"]:
            self.report.IndicateDetection(
                "Detected %d sections with invalid names" % badSectionNameCount
            )

    def BadEntryPointSectionDetector(self):  # TODO test
        if not self.config["CheckForBadEntryPointSections"]:
            return

        entryPoint = self.pe.OPTIONAL_HEADER.AddressOfEntryPoint
        if entryPoint == 0:
            self.report.IndicateSuspicion("Null entry point")
            return

        allSectionNames = []
        entryPointSectionNames = []
        for section in self.pe.sections:
            try:
                secName = self._GetCleanSectionName(section)
                allSectionNames.append(secName)
                if entryPoint >= section.VirtualAddress and entryPoint <= (
                    section.VirtualAddress + section.Misc_VirtualSize
                ):
                    entryPointSectionNames.append(secName)
            except UnicodeDecodeError:
                self.report.IndicateSuspicion("Section name with invalid characters")

        entryPointSectionCount = len(entryPointSectionNames)
        if entryPointSectionCount == 0:
            self.report.IndicateSuspicion(
                "Entry point 0x%x doesn't fall in valid section" % entryPoint
            )
        else:
            if entryPointSectionCount > 1:
                self.report.IndicateDetection(
                    "Entry point 0x%x falls in overlapping sections: %s"
                    % (entryPoint, self._FormatStringList(entryPointSectionNames))
                )

            if not self._DoListsIntersect(
                self.acceptableEntrySections, entryPointSectionNames
            ):
                badEpSec = False
                if self._DoListsIntersect(self.delphiBssSections, allSectionNames):
                    # has bss, see if we have a delphi ep section
                    badEpSec = not _DoListsIntersect(
                        self.delphiEntrySections, entryPointSectionNames
                    )
                elif not self._DoListsIntersect(
                    self.acceptableEntrySections, allSectionNames
                ):
                    # normal entry section doesn't exist anywhere, so check for alternatives
                    badEpSec = not self._DoListsIntersect(
                        self.alternativeEntrySections, entryPointSectionNames
                    )
                else:
                    # not regular ep section, not a delphi entry section, not an alternative entry section, and regular entry section name exists,
                    # so the only possibility left is a driver entry section
                    badEpSec = not self._DoListsIntersect(
                        self.driverEntrySection, entryPointSectionNames
                    )

                if badEpSec:
                    self.report.IndicateDetection(
                        "Entry point 0x%x in irregular section(s): %s"
                        % (entryPoint, self._FormatStringList(entryPointSectionNames))
                    )

    def check_section_entropy(self):
        res = []
        for s in self.pe.sections:
            if s.get_entropy() < 1 or s.get_entropy() > 7:
                res.append(
                    [s.Name.decode("utf-8", "ignore").strip("\x00"), s.get_entropy()]
                )

        if len(res) > 0:
            for r in res:
                self.report.IndicateSuspicion(("\t- %s - %3f" % (r[0], r[1])))

    def run(self):
        self.PEIDetector()
        self.PackerSectionNameDetector()
        self.LowImportCountDetector()
        self.NonStandardSectionNameDetector()
        self.BadEntryPointSectionDetector()
        self.check_section_entropy()
