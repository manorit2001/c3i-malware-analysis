import xml.etree.ElementTree as ET
from pathlib import Path

import pandas as pd
from scapy.all import *


class ExtractIOC:
    def parse_network_info(self, pcap_file, file):
        tcp_dst = set()
        udp_dst = set()
        pcap = rdpcap(pcap_file)
        Network_IOC = open(file, "w")

        for packet in pcap[TCP]:
            if "192.168" not in packet.dst and "127.0" not in packet.dst:
                tcp_dst.add(packet.dst)

        for packet in pcap[UDP]:
            if "192.168" not in packet.dst and "127.0" not in packet.dst:
                udp_dst.add(packet.dst)

        ips = tcp_dst.union(udp_dst)
        Network_IOC.write("\n NETWORK INDICATORS\n\n")
        Network_IOC.write("".join(ip + "\n" for ip in ips))

    def SaveKeys(self, snapshot):
        registry_keys = {}
        for keys in snapshot:
            keys = keys.split(b"\r\n")
            key_name = keys[0]
            registry_keys[key_name] = []
            keys.pop(0)
            for key in keys:
                if key != b"":
                    registry_keys[key_name].append(key)
        return registry_keys

    def parse_registry_info(
        self, log_dir, file
    ):  # If interested to know the values that has been changed in the given key Type of regshot
        changes = open(file, "wb")
        for i in range(5):
            before = open(log_dir / ("regshot_before" + str(i + 1)), "rb")
            after = open(log_dir / ("regshot_after" + str(i + 1)), "rb")

            snapshot_1 = before.read()[2:].split(b"\r\n\r\n")
            snapshot_2 = after.read()[2:].split(b"\r\n\r\n")

            registry_keys_1 = self.SaveKeys(snapshot_1)
            registry_keys_2 = self.SaveKeys(snapshot_2)

            extra_keys = [
                key
                for key in registry_keys_2.keys()
                if key not in registry_keys_1.keys()
            ]
            deleted_keys = [
                key
                for key in registry_keys_1.keys()
                if key not in registry_keys_2.keys()
            ]
            common_keys = [
                key for key in registry_keys_1.keys() if key in registry_keys_2.keys()
            ]

            changes.write(b"Keys Added\n\n")
            for key in extra_keys:
                changes.write(key + b"\n")
                changes.write(b"".join(value + b"\n" for value in registry_keys_2[key]))

            changes.write(b"Keys Deleted\n\n")
            for key in deleted_keys:
                changes.write(key + b"\n")
                changes.write(b"".join(value + b"\n" for value in registry_keys_1[key]))

            changes.write(b"Keys Changed\n\n")
            for key in common_keys:
                if registry_keys_1[key] != registry_keys_2[key]:
                    changes.write(key + b"\n")
                    for value_1, value_2 in zip(
                        registry_keys_1[key], registry_keys_2[key]
                    ):
                        if value_1 != value_2:
                            changes.write(b"Before -> " + value_1 + b"\n")
                            changes.write(b"After -> " + value_2 + b"\n")
                    if len(registry_keys_1[key]) < len(registry_keys_2[key]):
                        changes.write(
                            b"\nAdded Values\n"
                            + b"".join(
                                value + b"\n"
                                for value in registry_keys_2[key]
                                if value not in registry_keys_1[key]
                            )
                        )
                        changes.write(b"\n")
                    if len(registry_keys_1[key]) > len(registry_keys_2[key]):
                        changes.write(
                            b"\nDeleted Values\n"
                            + b"".join(
                                value + b"\n"
                                for value in registry_keys_1[key]
                                if value not in registry_keys_2[key]
                            )
                        )
                        changes.write(b"\n")
            before.close()
            after.close()
        changes.close()

    def parse_api_hooks_info(self, xml_file, parsed_dir):
        process_dir = parsed_dir / "process"
        process_dir.mkdir(parents=False, exist_ok=True)

        root = ET.parse(xml_file).getroot()
        pids = defaultdict(list)
        for event in root.findall("eventlist/event"):
            pids[(event[2].text, event[3].text)].append([event[4].text, event[5].text])

        for pid in pids.keys():
            pid_file = open(process_dir / str(pid[0]), "w")
            pid_file.write(pid[0] + ":" + pid[1] + "\n\n\n")
            for op in pids[pid]:
                pid_file.write("event\n")
                pid_file.write(op[0] + "\n")
                if op[1] != None:
                    pid_file.write(op[1] + "\n\n")
                else:
                    pid_file.write("None\n\n")

            pid_file.close()

    def parse_tcp_table_info(self, log_dir, parsed_dir):
        formats = ["tcp6", "udp6", "tcp", "udp6"]
        base = "network_{}_{}.csv"
        outputs = [
            ("both", "unchanged.csv"),
            ("left_only", "closed.csv"),
            ("right_only", "opened.csv"),
        ]

        base_output_dir = parsed_dir / "network_info"

        first = None
        second = None
        for f in formats:
            x = pd.read_csv(log_dir / base.format("before", f))
            y = pd.read_csv(log_dir / base.format("after", f))

            # add format type info
            x["type"] = f
            y["type"] = f

            if first is None:
                first = x
                continue
            if second is None:
                second = y
                continue

            first = first.append(x)
            second = second.append(y)

        merged = first.merge(second, how="outer", indicator=True)

        for _type, filename in outputs:
            iters = (
                merged.loc[merged["_merge"] == _type]
                .drop("_merge", axis=1)
                .reset_index(drop=True)
                .groupby("pid")
            )

            for pid, df in iters:
                output_dir = base_output_dir / str(pid)
                output_dir.mkdir(parents=True, exist_ok=True)

                # output directory name will have pid info, not needed here
                df.drop("pid", axis=1).to_csv(output_dir / filename)

    def run(self, log_dir, output_dir):
        log_dir = Path(log_dir)

        parsed_dir = Path(output_dir) / Path("parsed_dumps")
        parsed_dir.mkdir(parents=False, exist_ok=True)

        self.parse_network_info(
            str(log_dir / "example.pcap"), str(parsed_dir / "Network_changes.txt")
        )
        self.parse_tcp_table_info(log_dir, parsed_dir)
        self.parse_registry_info(log_dir, parsed_dir / "registry_changes.txt")
        self.parse_api_hooks_info(log_dir / "apimon.xml", parsed_dir)
