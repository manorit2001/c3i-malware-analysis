#include "tcp-table-test.h"

//#define _WINSOCK_DEPRECATED_NO_WARNINGS

int main() {
   
    getTCP();
    getUDP();
    getUDP6(); 
    getTCP6();  
	return 0;
}

void getTCP() {

    char szLocalAddr[128];
    char szRemoteAddr[128];

    struct in_addr IpAddr;


    TCHAR ApplicationName[MAX_PATH];
    string result = "";
    string aux = "";
    string RemotePort = "";
    string OpenedPort = "";
    MIB_TCPTABLE_OWNER_PID* pTCPInfo;
    MIB_TCPROW_OWNER_PID* owner;
    DWORD size;
    DWORD dwResult;
    dwResult = GetExtendedTcpTable(NULL, &size, false, AF_INET, TCP_TABLE_OWNER_PID_ALL, 0);
    pTCPInfo = (MIB_TCPTABLE_OWNER_PID*)malloc(size);
    dwResult = GetExtendedTcpTable(pTCPInfo, &size, false, AF_INET, TCP_TABLE_OWNER_PID_ALL, 0);

    ofstream tcpfile;
    tcpfile.open("tcp_connections.txt");

    tcpfile << "pid,state,local_addr,local_port,remote_addr,remote_port\n";

    for (DWORD dwLoop = 0; dwLoop < pTCPInfo->dwNumEntries; dwLoop++)
    {
        owner = &pTCPInfo->table[dwLoop];
        //int _x = GetNameByPID(owner->dwOwningPid, ApplicationName);
        //cout << "_x = " << _x << "\n";
        OpenedPort = to_string(ntohs((u_short) owner->dwLocalPort));
        RemotePort = to_string(ntohs((u_short)owner->dwRemotePort));
        //aux = "TCP ; " + OpenedPort + ";" + RemotePort + ";" + "\n";
        //result = result + aux;
        //cout << owner->dwOwningPid << "," << owner->dwLocalAddr << "," << owner->dwLocalPort << "," << owner->dwRemoteAddr << "," << owner->dwRemotePort << "\n";
        //cout << owner->dwOwningPid << "," << ntohl(owner->dwLocalAddr) << "," << OpenedPort << "," << ntohl(owner->dwRemoteAddr) << "," << RemotePort << "\n";

        IpAddr.S_un.S_addr = (u_long)owner->dwLocalAddr;
        strcpy_s(szLocalAddr, sizeof(szLocalAddr), inet_ntoa(IpAddr));

        IpAddr.S_un.S_addr = (u_long)owner->dwRemoteAddr;
        strcpy_s(szRemoteAddr, sizeof(szRemoteAddr), inet_ntoa(IpAddr));

        tcpfile << owner->dwOwningPid << "," << owner->dwState << "," << szLocalAddr << "," <<  OpenedPort <<"," << szRemoteAddr << "," << RemotePort << "\n";

        /*if (_x == 0) {
            cout <<"process name"<< ApplicationName ;
        }
        cout << owner->dwOwningPid << " == " << OpenedPort << " == " << RemotePort << " == " << aux << "\n";*/

    }

    tcpfile.close();
}

void getUDP() {

    char szLocalAddr[128];
    char szRemoteAddr[128];

    struct in_addr IpAddr;

    TCHAR ApplicationName[MAX_PATH];
    string result = "";
    string aux = "";
    string RemotePort = "";
    string OpenedPort = "";
    MIB_UDPTABLE_OWNER_PID* pTCPInfo;
    MIB_UDPROW_OWNER_PID* owner;
    DWORD size;
    DWORD dwResult;
    dwResult = GetExtendedUdpTable(NULL, &size, false, AF_INET, UDP_TABLE_OWNER_PID, 0);
    pTCPInfo = (MIB_UDPTABLE_OWNER_PID*)malloc(size);
    dwResult = GetExtendedUdpTable(pTCPInfo, &size, false, AF_INET, UDP_TABLE_OWNER_PID, 0);

    ofstream tcpfile;
    tcpfile.open("udp_connections.txt");

    tcpfile << "pid,local_addr,local_port\n";

    for (DWORD dwLoop = 0; dwLoop < pTCPInfo->dwNumEntries; dwLoop++)
    {
        owner = &pTCPInfo->table[dwLoop];
        OpenedPort = to_string(ntohs((u_short)owner->dwLocalPort));
        IpAddr.S_un.S_addr = (u_long)owner->dwLocalAddr;
        strcpy_s(szLocalAddr, sizeof(szLocalAddr), inet_ntoa(IpAddr));
        tcpfile << owner->dwOwningPid << "," << szLocalAddr << "," << OpenedPort << "\n";
    }

    tcpfile.close();
}

void getUDP6() {

    wchar_t ipstringbuffer[46];

    TCHAR ApplicationName[MAX_PATH];
    string RemotePort = "";
    string OpenedPort = "";
    MIB_UDP6TABLE_OWNER_PID* pTCPInfo;
    MIB_UDP6ROW_OWNER_PID* owner;
    DWORD size = 0;
    DWORD dwResult;
    dwResult = GetExtendedUdpTable(NULL, &size, false, AF_INET6, UDP_TABLE_OWNER_PID, 0);
    pTCPInfo = (MIB_UDP6TABLE_OWNER_PID*)malloc(size);
    dwResult = GetExtendedUdpTable(pTCPInfo, &size, false, AF_INET6, UDP_TABLE_OWNER_PID, 0);

    ofstream tcpfile;
    tcpfile.open("udp6_connections.txt");

    tcpfile << "pid,local_addr,local_port,LocalScopeId,\n";

    for (DWORD dwLoop = 0; dwLoop < pTCPInfo->dwNumEntries; dwLoop++)
    {
        owner = &pTCPInfo->table[dwLoop];
        OpenedPort = to_string(ntohs(owner->dwLocalPort));
        InetNtop(AF_INET6, owner->ucLocalAddr, ipstringbuffer, 46);

        tcpfile << owner->dwOwningPid << "," << ipstringbuffer << "," << owner->dwLocalPort << "," << owner->dwLocalScopeId << "\n";

    }

    tcpfile.close();
}

int GetNameByPID(int pid, TCHAR* x) {
    cout << "pid"<< pid<<"\n";
    HANDLE Handle = OpenProcess(
        PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
        FALSE,
        pid 
    );
    if (Handle)
    {
        TCHAR Buffer[MAX_PATH];

        if (GetModuleBaseName(Handle, NULL, Buffer, MAX_PATH)) {
            printf("\ngetmodule %s", Buffer);
        }
        else {
            printf("else ");
        }

        if (GetModuleFileNameEx(Handle, 0, x, MAX_PATH))
        {
            if (x == NULL) {
                return -1;
            }
        }
        else
        {
            return -1;
        }
        CloseHandle(Handle);
        return 0;
    }

    return 2;
}

void getTCP6() {
    wchar_t ipstringbuffer[46];
    wchar_t ipstringbuffer2[46];

    string RemotePort = "";
    string OpenedPort = "";
    MIB_TCP6TABLE_OWNER_PID* pTCPInfo;
    MIB_TCP6ROW_OWNER_PID* owner;
    DWORD size = 0;
    DWORD dwResult;
    dwResult = GetExtendedTcpTable(NULL, &size, false, AF_INET6, TCP_TABLE_OWNER_PID_ALL, 0);
    pTCPInfo = (MIB_TCP6TABLE_OWNER_PID*)malloc(size);
    dwResult = GetExtendedTcpTable(pTCPInfo, &size, false, AF_INET6, TCP_TABLE_OWNER_PID_ALL, 0);

    ofstream tcpfile;
    tcpfile.open("tcp6_connections.txt");

    tcpfile << "pid,local_addr,local_port,remote_addr,remote_port,state\n";

    for (DWORD dwLoop = 0; dwLoop < pTCPInfo->dwNumEntries; dwLoop++)
    {
        owner = &pTCPInfo->table[dwLoop];
        OpenedPort = to_string(ntohs(owner->dwLocalPort));
        RemotePort = to_string(ntohs(owner->dwRemotePort));
        InetNtop(AF_INET6, owner->ucLocalAddr, ipstringbuffer, 46);
        InetNtop(AF_INET6, owner->ucRemoteAddr, ipstringbuffer2, 46);

        tcpfile << owner->dwOwningPid << "," << ipstringbuffer << "," << owner->dwLocalPort << "," << ipstringbuffer2 << "," << owner->dwRemotePort <<","<< owner->dwState <<"\n";

    }

    tcpfile.close();
}

    
    

/*Port::GetListOfTcpPorts()
TCHAR ApplicationName[MAX_PATH];
    string result = "";
    string aux = "";
    string RemotePort = "";
    string OpenedPort = "";
    MIB_TCP6TABLE_OWNER_PID* pTCPInfo;
    MIB_TCP6ROW_OWNER_PID* owner;
    DWORD size = 0;
    DWORD dwResult;
    DWORD dwRetVal = 0;

    pTCPInfo = (MIB_TCP6TABLE_OWNER_PID*)malloc(sizeof(MIB_TCP6TABLE_OWNER_PID));
    if (pTCPInfo == NULL) {
        cout << "Error allocating memory pTCPInfo\n";
        return;
    }

    //size = sizeof(MIB_TCP6TABLE_OWNER_PID);

    dwResult = GetExtendedTcpTable(NULL, &size, false, AF_INET6, TCP_TABLE_OWNER_PID_ALL, 0);

    /*if (dwResult == ERROR_INSUFFICIENT_BUFFER) {
        FREE(pTCPInfo);
        pTCPInfo = (MIB_TCP6TABLE_OWNER_PID*)MALLOC(size);
        if (pTCPInfo == NULL) {
            cout << "Error allocating memory \n";
            return;
        }
    }

dwResult = GetExtendedTcpTable(pTCPInfo, &size, false, AF_INET6, TCP_TABLE_OWNER_PID_ALL, 0);

if (dwResult == NO_ERROR) {
    ofstream tcpfile;

    tcpfile.open("tcp6_connections.txt");

    tcpfile << "pid,local_addr,local_port,remote_addr,remote_port,state\n";

    for (DWORD dwLoop = 0; dwLoop < pTCPInfo->dwNumEntries; dwLoop++)
    {

        cout << 124 << "\n";

        owner = &pTCPInfo->table[dwLoop];

        if (InetNtop(AF_INET6, owner->ucLocalAddr, ipstringbuffer, 46) == NULL) {
            cout << "  InetNtop function failed for local IPv6 address\n";
        }
        if (InetNtop(AF_INET6, owner->ucRemoteAddr, ipstringbuffer, 46) == NULL) {
            cout << "  InetNtop function failed for remote IPv6 address\n";
        }

        cout << owner->dwOwningPid << "," << ipstringbuffer << "," << ntohs((u_short)owner->dwLocalPort) << "," << ipstringbuffer2 << "," << ntohs((u_short)owner->dwRemotePort) << "," << owner->dwState << "\n";

    }

    tcpfile.close();

}
else {
    cout << "GetTcp6Table failed with " << dwResult << "\n";
}
{
    string ApplicationName = "";
    string result = "";
    string aux = "";
    string RemotePort = "";
    DWORD(WINAPI * pGetExtendedTcpTable)(
        PVOID pTcpTable,
        PDWORD pdwSize,
        BOOL bOrder,
        ULONG ulAf,
        TCP_TABLE_CLASS TableClass,
        ULONG Reserved
        );
    MIB_TCPTABLE_OWNER_PID* pTCPInfo;
    MIB_TCPROW_OWNER_PID* owner;
    DWORD size;
    DWORD dwResult;

    //HMODULE hLib = LoadLibrary("iphlpapi.dll");

    //pGetExtendedTcpTable = (DWORD(WINAPI*)(PVOID, PDWORD, BOOL, ULONG, TCP_TABLE_CLASS, ULONG))
        //GetProcAddress(hLib, "GetExtendedTcpTable");

    dwResult = GetExtendedTcpTable(NULL, &size, false, AF_INET, TCP_TABLE_OWNER_PID_LISTENER, 0);
    pTCPInfo = (MIB_TCPTABLE_OWNER_PID*)malloc(size);
    dwResult = pGetExtendedTcpTable(pTCPInfo, &size, false, AF_INET, TCP_TABLE_OWNER_PID_LISTENER, 0);
    for (DWORD dwLoop = 0; dwLoop < pTCPInfo->dwNumEntries; dwLoop++)
    {
        owner = &pTCPInfo->table[dwLoop];
        ApplicationName = GetNameByPID(owner->dwOwningPid); 
        OpenedPort = convertInt(ntohs(owner->dwLocalPort));
        RemotePort = convertInt(ntohs(owner->dwRemotePort));
        aux = "TCP ; " + OpenedPort + ";" + RemotePort + ";" + ApplicationName + "\n";
        result = result + aux;

    }
    return result;
}
*/