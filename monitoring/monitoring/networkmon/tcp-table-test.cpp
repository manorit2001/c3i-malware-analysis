#include "tcp-table-test.h"

void NetworkMon::getTCP() {

	char szLocalAddr[128];
	char szRemoteAddr[128];
	struct in_addr IpAddr;
	TCHAR ApplicationName[MAX_PATH];
	string result = "";
	string aux = "";
	string RemotePort = "";
	string OpenedPort = "";
	MIB_TCPTABLE_OWNER_PID* pTCPInfo;
	MIB_TCPROW_OWNER_PID* owner;
	DWORD size;
	DWORD dwResult;

	dwResult = GetExtendedTcpTable(NULL, &size, false, AF_INET, TCP_TABLE_OWNER_PID_ALL, 0);
	pTCPInfo = (MIB_TCPTABLE_OWNER_PID*)malloc(size);
	dwResult = GetExtendedTcpTable(pTCPInfo, &size, false, AF_INET, TCP_TABLE_OWNER_PID_ALL, 0);

	ofstream tcpfile;
	tcpfile.open(filename + "_tcp.csv");

	tcpfile << "pid,state,local_addr,local_port,remote_addr,remote_port\n";

	for (DWORD dwLoop = 0; dwLoop < pTCPInfo->dwNumEntries; dwLoop++)
	{
		owner = &pTCPInfo->table[dwLoop];
		OpenedPort = to_string(ntohs((u_short)owner->dwLocalPort));
		RemotePort = to_string(ntohs((u_short)owner->dwRemotePort));

		IpAddr.S_un.S_addr = (u_long)owner->dwLocalAddr;
		strcpy_s(szLocalAddr, sizeof(szLocalAddr), inet_ntoa(IpAddr));

		IpAddr.S_un.S_addr = (u_long)owner->dwRemoteAddr;
		strcpy_s(szRemoteAddr, sizeof(szRemoteAddr), inet_ntoa(IpAddr));

		tcpfile << owner->dwOwningPid << "," << owner->dwState << "," << szLocalAddr << "," << OpenedPort << "," << szRemoteAddr << "," << RemotePort << "\n";
	}

	tcpfile.close();
}

void NetworkMon::getUDP() {

	char szLocalAddr[128];
	char szRemoteAddr[128];

	struct in_addr IpAddr;

	TCHAR ApplicationName[MAX_PATH];
	string result = "";
	string aux = "";
	string RemotePort = "";
	string OpenedPort = "";
	MIB_UDPTABLE_OWNER_PID* pTCPInfo;
	MIB_UDPROW_OWNER_PID* owner;
	DWORD size;
	DWORD dwResult;
	dwResult = GetExtendedUdpTable(NULL, &size, false, AF_INET, UDP_TABLE_OWNER_PID, 0);
	pTCPInfo = (MIB_UDPTABLE_OWNER_PID*)malloc(size);
	dwResult = GetExtendedUdpTable(pTCPInfo, &size, false, AF_INET, UDP_TABLE_OWNER_PID, 0);

	ofstream tcpfile;
	tcpfile.open(filename + "_udp.csv");

	tcpfile << "pid,local_addr,local_port\n";

	for (DWORD dwLoop = 0; dwLoop < pTCPInfo->dwNumEntries; dwLoop++)
	{
		owner = &pTCPInfo->table[dwLoop];
		OpenedPort = to_string(ntohs((u_short)owner->dwLocalPort));
		IpAddr.S_un.S_addr = (u_long)owner->dwLocalAddr;
		strcpy_s(szLocalAddr, sizeof(szLocalAddr), inet_ntoa(IpAddr));
		tcpfile << owner->dwOwningPid << "," << szLocalAddr << "," << OpenedPort << "\n";
	}

	tcpfile.close();
}

void NetworkMon::getUDP6() {

	wchar_t ipstringbuffer[46];

	TCHAR ApplicationName[MAX_PATH];
	string RemotePort = "";
	string OpenedPort = "";
	MIB_UDP6TABLE_OWNER_PID* pTCPInfo;
	MIB_UDP6ROW_OWNER_PID* owner;
	DWORD size = 0;
	DWORD dwResult;
	dwResult = GetExtendedUdpTable(NULL, &size, false, AF_INET6, UDP_TABLE_OWNER_PID, 0);
	pTCPInfo = (MIB_UDP6TABLE_OWNER_PID*)malloc(size);
	dwResult = GetExtendedUdpTable(pTCPInfo, &size, false, AF_INET6, UDP_TABLE_OWNER_PID, 0);

	ofstream tcpfile;
	tcpfile.open(filename + "_udp6.csv");

	tcpfile << "pid,local_addr,local_port,LocalScopeId\n";

	for (DWORD dwLoop = 0; dwLoop < pTCPInfo->dwNumEntries; dwLoop++)
	{
		owner = &pTCPInfo->table[dwLoop];
		OpenedPort = to_string(ntohs(owner->dwLocalPort));
		InetNtop(AF_INET6, owner->ucLocalAddr, ipstringbuffer, 46);

		tcpfile << owner->dwOwningPid << "," << ipstringbuffer << "," << owner->dwLocalPort << "," << owner->dwLocalScopeId << "\n";

	}

	tcpfile.close();
}

int NetworkMon::GetNameByPID(int pid, TCHAR* x) {
	cout << "pid" << pid << "\n";
	HANDLE Handle = OpenProcess(
		PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
		FALSE,
		pid
	);
	if (Handle)
	{
		TCHAR Buffer[MAX_PATH];

		if (GetModuleBaseName(Handle, NULL, Buffer, MAX_PATH)) {
			printf("\ngetmodule %s", Buffer);
		}
		else {
			printf("else ");
		}

		if (GetModuleFileNameEx(Handle, 0, x, MAX_PATH))
		{
			if (x == NULL) {
				return -1;
			}
		}
		else
		{
			return -1;
		}
		CloseHandle(Handle);
		return 0;
	}

	return 2;
}

void NetworkMon::getTCP6() {
	wchar_t ipstringbuffer[46];
	wchar_t ipstringbuffer2[46];

	string RemotePort = "";
	string OpenedPort = "";
	MIB_TCP6TABLE_OWNER_PID* pTCPInfo;
	MIB_TCP6ROW_OWNER_PID* owner;
	DWORD size = 0;
	DWORD dwResult;
	dwResult = GetExtendedTcpTable(NULL, &size, false, AF_INET6, TCP_TABLE_OWNER_PID_ALL, 0);
	pTCPInfo = (MIB_TCP6TABLE_OWNER_PID*)malloc(size);
	dwResult = GetExtendedTcpTable(pTCPInfo, &size, false, AF_INET6, TCP_TABLE_OWNER_PID_ALL, 0);

	ofstream tcpfile;
	tcpfile.open(filename + "_tcp6.csv");

	tcpfile << "pid,local_addr,local_port,remote_addr,remote_port,state\n";

	for (DWORD dwLoop = 0; dwLoop < pTCPInfo->dwNumEntries; dwLoop++)
	{
		owner = &pTCPInfo->table[dwLoop];
		OpenedPort = to_string(ntohs(owner->dwLocalPort));
		RemotePort = to_string(ntohs(owner->dwRemotePort));
		InetNtop(AF_INET6, owner->ucLocalAddr, ipstringbuffer, 46);
		InetNtop(AF_INET6, owner->ucRemoteAddr, ipstringbuffer2, 46);

		tcpfile << owner->dwOwningPid << "," << ipstringbuffer << "," << owner->dwLocalPort << "," << ipstringbuffer2 << "," << owner->dwRemotePort << "," << owner->dwState << "\n";

	}

	tcpfile.close();
}
