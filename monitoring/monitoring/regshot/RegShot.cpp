

#include "RegShot.h"

// Print the contents with the appropriate data type

void RegShot::printSuitableData(TCHAR* name, DWORD type, DWORD size, vector<BYTE>& buffer, FILE* fp) {
    if (type == REG_SZ || type == REG_EXPAND_SZ || type == REG_MULTI_SZ) {
        _ftprintf(fp, TEXT("%s : %.*s\n"), name, size, &buffer[0]);
    }
    else if (type == REG_DWORD || type == REG_DWORD_LITTLE_ENDIAN) {
        int value;
        memcpy((void*)&value, (void*)&buffer[0], 4);
        _ftprintf(fp, TEXT("%s : 0x%08x\n"), name, value);
    }
    else if (type == REG_BINARY) {
        _ftprintf(fp, TEXT("%s : "), name, size, &buffer[0]);
        for (int i = 0; i < size; i++) {
            _ftprintf(fp, TEXT("0x%02x "), buffer[i]);
        }
    }
    else if (type == REG_QWORD || type == REG_QWORD_LITTLE_ENDIAN) {
        long long int value;
        memcpy(&value, (void*)&buffer[0], 8);
        _ftprintf(fp, TEXT("%s : 0x%p\n"), name, value);
    }
    else if (type == REG_NONE) {
        _ftprintf(fp, TEXT("%s : NULL"), name);
    }
    else {
        _ftprintf(fp, TEXT("%s : %.*s\n"), name, size, &buffer[0]);
    }
}

// Query each key and save the contents in the file. Performs Depth First Search.

void RegShot::recursivelySaveKeys(HKEY hKey, tstring name, int RecursiveDepth, FILE* fp) {
    TCHAR   achKey[MAX_KEY_LENGTH];   // buffer for subkey name
    DWORD    cbName;                   // size of name string 
    TCHAR    achClass[MAX_PATH] = TEXT("");  // buffer for class name 
    DWORD    cchClassName = MAX_PATH;  // size of class string 
    DWORD    cSubKeys = 0;               // number of subkeys 
    DWORD    cbMaxSubKey;              // longest subkey size 
    DWORD    cchMaxClass;              // longest class string 
    DWORD    cValues;              // number of values for key 
    DWORD    cchMaxValue;          // longest value name 
    DWORD    cbMaxValueData;       // longest value data 
    DWORD    cbSecurityDescriptor; // size of security descriptor 
    FILETIME ftLastWriteTime;      // last write time 

    DWORD retCode;
    unsigned long i;

    //TCHAR  achValue[MAX_VALUE_NAME];
    TCHAR* achValue = new TCHAR[MAX_VALUE_NAME];
    DWORD cchValue = MAX_VALUE_NAME;

    // Get the class name and the value count. 
    retCode = RegQueryInfoKey(
        hKey,
        achClass,
        &cchClassName,
        NULL,
        &cSubKeys,
        &cbMaxSubKey,
        &cchMaxClass,
        &cValues,
        &cchMaxValue,
        &cbMaxValueData,
        &cbSecurityDescriptor,
        &ftLastWriteTime);

    if (retCode != ERROR_SUCCESS) {
        return;
    }
    _ftprintf(fp, TEXT("\n[%s]\n"), name.c_str());
    if (cValues)
    {

        vector<BYTE> buffer(cbMaxValueData + 1);
        for (i = 0; i < cValues; ++i)
        {
            cchValue = MAX_VALUE_NAME;
            retCode = RegEnumValue(hKey, i, achValue, &cchValue, NULL, NULL, NULL, NULL);
            if (retCode == ERROR_SUCCESS)
            {
                DWORD lpData = cbMaxValueData, type;
                retCode = RegQueryValueEx(hKey, achValue, 0, &type, &buffer[0], &lpData);
                if (retCode == ERROR_SUCCESS) {
                    if (achValue[0] == NULL) {
                        _tcscpy_s(achValue, 5, _TEXT("NULL"));
                    }
                    printSuitableData(achValue, type, lpData, buffer, fp);
                }

            }
        }
        delete[]achValue;
    }
    else {
        _ftprintf(fp, TEXT("NULL : NULL\n"));
    }


    if ((cSubKeys) && (RecursiveDepth != 0))
    {

        int NextDepth = RecursiveDepth;
        if (NextDepth > 0) --NextDepth;

        vector<tstring> subKeys;
        subKeys.reserve(cSubKeys);

        for (i = 0; i < cSubKeys; ++i)
        {
            cbName = MAX_KEY_LENGTH;
            retCode = RegEnumKeyEx(hKey, i, achKey, &cbName, NULL, NULL, NULL, &ftLastWriteTime);
            if (retCode == ERROR_SUCCESS)
            {
                subKeys.push_back(achKey);
            }
        }

        for (vector<tstring>::iterator iter = subKeys.begin(), end = subKeys.end(); iter != end; ++iter)
        {
            HKEY hTestKey;
            if (RegOpenKeyEx(hKey, iter->c_str(), 0, KEY_ALL_ACCESS | KEY_WOW64_64KEY, &hTestKey) == ERROR_SUCCESS)
            {
                recursivelySaveKeys(hTestKey, name + TEXT("\\") + *iter, NextDepth, fp);
                RegCloseKey(hTestKey);
            }
        }
    }
}

// Constructor for taking the main root keys

RegShot::RegShot(vector <pair<HKEY, wstring>>& keys) {
    rootKeys.assign(keys.begin(), keys.end());
}

// Take the Registry Snapshot for the given root keys

void RegShot::takeSnapShot(string file) {
    FILE* fp;
    int counter = 1;
    for (auto root : rootKeys) {
        string save = file + to_string(counter);
        fopen_s(&fp, &save[0], "w");
        wcout << "[*] Started Writing " << root.second << " subkeys to the given file" << endl;
        TCHAR* name = (TCHAR*)malloc(MAX_KEY_LENGTH);
        //_tcscpy_s(name, 1000, root.second.c_str());
        recursivelySaveKeys(root.first, root.second, -1, fp);
        fclose(fp);
        wcout << "[*] Completed writing " << root.second << " subkeys to the given file" << endl;
        counter++;
    }
}