import configparser
import datetime
import logging
import shutil
import subprocess
import sys
import tempfile
import time
import zipfile
from pathlib import Path

import requests
from elevate import elevate


def send_file(api, file_path, name, timestamp):
    logging.info(f"Sending file {file_path}")
    if not file_path.exists():
        logging.warning(f"file doesn't exist {file_path}")
        return False
    else:
        with open(file_path, "rb") as f:
            r = requests.post(
                api + "/upload",
                data={"name": str(name), "timestamp": timestamp},
                files={"file": f},
            )
            if r.ok:
                logging.info(f"Uploaded {file_path}")
                return True
            else:
                logging.warning(f"Failed on {file_path}")
                return False


def get_list_of_files():
    # update the list of files when anything added to monitoring engine
    list_of_files = ["log.etl", "procmon.out", "etw.etl", "log.cab", "apimon.xml"]

    for j in ["before", "after"]:
        for i in ["tcp", "udp", "tcp6", "udp6"]:
            list_of_files += [f"network_{j}_{i}.csv"]
        for i in range(1, 6):
            list_of_files += [f"regshot_{j}{i}"]

    return list_of_files


def setup_monitoring_folder(log_dir, name=None):
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")

    cur_monitoring_folder = log_dir / timestamp

    logging.info(f"Creating log_dir {cur_monitoring_folder}")

    cur_monitoring_folder.mkdir(parents=True)
    return cur_monitoring_folder, timestamp


def compress_logs(cur_monitoring_dir, timestamp):
    tempf = tempfile.NamedTemporaryFile(delete=False, suffix=".zip")
    zipf = zipfile.ZipFile(tempf.name, "w", zipfile.ZIP_DEFLATED)
    list_of_files = get_list_of_files()

    ## For compressing all the files
    # for file in cur_monitoring_dir.rglob('*'):
    #    ziph.write(file)

    ## compressing using list_of_files
    for file in list_of_files:
        zipf.write(cur_monitoring_dir / file, arcname=Path(timestamp) / file)

    zipf.close()
    return Path(tempf.name)


"""
usage: python3 client.py <path-to-malware>(optional)
"""
if __name__ == "__main__":
    elevate()

    logging.basicConfig(
        level=logging.DEBUG,
        format="[%(asctime)s][%(levelname)s] %(message)s",
        handlers=[logging.StreamHandler()],
    )
    conf_file = Path(__file__) / "../config.ini"
    conf_file = conf_file.resolve()

    config = configparser.ConfigParser()
    config.read(conf_file)

    api = config["DEFAULT"]["API_URL"]
    log_dir = Path(config["DEFAULT"]["LOG_DIR"]) / "Monitoring"
    exe_path = Path(config["DEFAULT"]["EXE_PATH"]).absolute().resolve()

    if log_dir.exists() and not log_dir.is_dir():
        logging.error("LOG_DIR path is not a directory")

    cmd = [str(exe_path)]
    logging.debug(f"sys.argv: {sys.argv}")

    malware_file = (
        Path(sys.argv[1]).absolute().resolve() if len(sys.argv) == 2 else None
    )
    logging.debug(f"malware_file: {malware_file}")

    infinite_loop = True
    list_of_files = get_list_of_files()
    malware_file_name = malware_file.parts[-1] if malware_file else None
    logging.debug(f"malware_file_name: {malware_file_name}")

    while infinite_loop:
        cur_monitoring_folder, timestamp = setup_monitoring_folder(
            log_dir, malware_file_name
        )
        new_cmd = cmd + [str(cur_monitoring_folder)]

        if malware_file:
            new_cmd += [str(malware_file)]
            infinite_loop = False

        logging.info(f"Running command {new_cmd}")
        try:
            subprocess.run(new_cmd)
        except KeyboardInterrupt:
            logging.info("Cleaning up corrupted logs")
            shutil.rmtree(cur_monitoring_folder)
            sys.exit(1)

        zip_file = compress_logs(cur_monitoring_folder, timestamp)
        send_file(api, zip_file, malware_file_name, timestamp)

        zip_file.unlink()
        if config["DEFAULT"].getboolean("AUTO_DEL", False):
            shutil.rmtree(cur_monitoring_folder)

        if not malware_file:
            time.sleep(20)
