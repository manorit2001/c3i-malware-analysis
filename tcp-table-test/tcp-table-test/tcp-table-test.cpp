// Need to link with Iphlpapi.lib and Ws2_32.lib
#include <winsock2.h>
#include <ws2tcpip.h>
#include <iphlpapi.h>
#include <stdio.h>
#include <Psapi.h>

#include <fstream>

#include <winsock.h>

#include <iostream>
#include <string> 

using namespace std;

#pragma comment(lib, "iphlpapi.lib")
#pragma comment(lib, "ws2_32.lib")

#define MALLOC(x) HeapAlloc(GetProcessHeap(), 0, (x))
#define FREE(x) HeapFree(GetProcessHeap(), 0, (x))

/* Note: could also use malloc() and free() */

int GetNameByPID(int pid, TCHAR* x);

void getTCP();

void getUDP();

void getUDP6();

void getTCP6();

int main() {
   
    getTCP();
    getUDP();
    getUDP6(); //still have to figure of localAddr and why its giving gibberish
    getTCP6();  //still have to figure of localAddr and why its giving gibberish
	return 0;
}

void getTCP() {
    TCHAR ApplicationName[MAX_PATH];
    string result = "";
    string aux = "";
    string RemotePort = "";
    string OpenedPort = "";
    MIB_TCPTABLE_OWNER_PID* pTCPInfo;
    MIB_TCPROW_OWNER_PID* owner;
    DWORD size;
    DWORD dwResult;
    dwResult = GetExtendedTcpTable(NULL, &size, false, AF_INET, TCP_TABLE_OWNER_PID_ALL, 0);
    pTCPInfo = (MIB_TCPTABLE_OWNER_PID*)malloc(size);
    dwResult = GetExtendedTcpTable(pTCPInfo, &size, false, AF_INET, TCP_TABLE_OWNER_PID_ALL, 0);

    ofstream tcpfile;
    tcpfile.open("tcp_connections.txt");

    tcpfile << "pid,local_addr,local_port,remote_addr,remote_port\n";

    for (DWORD dwLoop = 0; dwLoop < pTCPInfo->dwNumEntries; dwLoop++)
    {
        owner = &pTCPInfo->table[dwLoop];
        //int _x = GetNameByPID(owner->dwOwningPid, ApplicationName);
        //cout << "_x = " << _x << "\n";
        OpenedPort = to_string(ntohs(owner->dwLocalPort));
        RemotePort = to_string(ntohs(owner->dwRemotePort));
        //aux = "TCP ; " + OpenedPort + ";" + RemotePort + ";" + "\n";
        //result = result + aux;
        tcpfile << owner->dwOwningPid << "," << owner->dwLocalAddr << "," << owner->dwLocalPort << "," << owner->dwRemoteAddr << "," << owner->dwRemotePort << "\n";
        /*if (_x == 0) {
            cout <<"process name"<< ApplicationName ;
        }
        cout << owner->dwOwningPid << " == " << OpenedPort << " == " << RemotePort << " == " << aux << "\n";*/

    }

    tcpfile.close();
}

void getUDP() {
    TCHAR ApplicationName[MAX_PATH];
    string result = "";
    string aux = "";
    string RemotePort = "";
    string OpenedPort = "";
    MIB_UDPTABLE_OWNER_PID* pTCPInfo;
    MIB_UDPROW_OWNER_PID* owner;
    DWORD size;
    DWORD dwResult;
    dwResult = GetExtendedUdpTable(NULL, &size, false, AF_INET, UDP_TABLE_OWNER_PID, 0);
    pTCPInfo = (MIB_UDPTABLE_OWNER_PID*)malloc(size);
    dwResult = GetExtendedUdpTable(pTCPInfo, &size, false, AF_INET, UDP_TABLE_OWNER_PID, 0);

    ofstream tcpfile;
    tcpfile.open("udp_connections.txt");

    tcpfile << "pid,local_addr,local_port\n";

    for (DWORD dwLoop = 0; dwLoop < pTCPInfo->dwNumEntries; dwLoop++)
    {
        owner = &pTCPInfo->table[dwLoop];
        OpenedPort = to_string(ntohs(owner->dwLocalPort));
        tcpfile << owner->dwOwningPid << "," << owner->dwLocalAddr << "," << owner->dwLocalPort << "\n";

    }

    tcpfile.close();
}

void getUDP6() {
    TCHAR ApplicationName[MAX_PATH];
    string result = "";
    string aux = "";
    string RemotePort = "";
    string OpenedPort = "";
    MIB_UDP6TABLE_OWNER_PID* pTCPInfo;
    MIB_UDP6ROW_OWNER_PID* owner;
    DWORD size = 0;
    DWORD dwResult;
    dwResult = GetExtendedUdpTable(NULL, &size, false, AF_INET6, UDP_TABLE_OWNER_PID, 0);
    pTCPInfo = (MIB_UDP6TABLE_OWNER_PID*)malloc(size);
    dwResult = GetExtendedUdpTable(pTCPInfo, &size, false, AF_INET6, UDP_TABLE_OWNER_PID, 0);

    ofstream tcpfile;
    tcpfile.open("udp6_connections.txt");

    tcpfile << "pid,local_port,local_addr,LocalScopeId,\n";

    for (DWORD dwLoop = 0; dwLoop < pTCPInfo->dwNumEntries; dwLoop++)
    {
        owner = &pTCPInfo->table[dwLoop];
        OpenedPort = to_string(ntohs(owner->dwLocalPort));
        
        tcpfile << owner->dwOwningPid << "," << owner->ucLocalAddr << "," << owner->dwLocalPort << "," << owner->dwLocalScopeId << "\n";

    }

    tcpfile.close();
}

int GetNameByPID(int pid, TCHAR* x) {
    cout << "pid"<< pid<<"\n";
    HANDLE Handle = OpenProcess(
        PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
        FALSE,
        pid 
    );
    if (Handle)
    {
        TCHAR Buffer[MAX_PATH];

        if (GetModuleBaseName(Handle, NULL, Buffer, MAX_PATH)) {
            printf("\ngetmodule %s", Buffer);
        }
        else {
            printf("else ");
        }

        if (GetModuleFileNameEx(Handle, 0, x, MAX_PATH))
        {
            if (x == NULL) {
                return -1;
            }
        }
        else
        {
            return -1;
        }
        CloseHandle(Handle);
        return 0;
    }

    return 2;
}

void getTCP6() {
    TCHAR ApplicationName[MAX_PATH];
    string result = "";
    string aux = "";
    string RemotePort = "";
    string OpenedPort = "";
    MIB_TCP6TABLE_OWNER_PID* pTCPInfo;
    MIB_TCP6ROW_OWNER_PID* owner;
    DWORD size = 0;
    DWORD dwResult;
    dwResult = GetExtendedTcpTable(NULL, &size, false, AF_INET, TCP_TABLE_OWNER_PID_ALL, 0);
    pTCPInfo = (MIB_TCP6TABLE_OWNER_PID*)malloc(size);
    dwResult = GetExtendedTcpTable(pTCPInfo, &size, false, AF_INET, TCP_TABLE_OWNER_PID_ALL, 0);

    ofstream tcpfile;
    //tcpfile.open("tcp6_connections.txt");

    //tcpfile << "pid,local_addr,local_port,remote_addr,remote_port,state\n";
    
    for (DWORD dwLoop = 0; dwLoop < pTCPInfo->dwNumEntries; dwLoop++)
    {
        owner = &pTCPInfo->table[dwLoop]; 
        OpenedPort = to_string(ntohs(owner->dwLocalPort));
        RemotePort = to_string(ntohs(owner->dwRemotePort));
        //tcpfile << owner->dwOwningPid << "," << owner->ucLocalAddr << "," << owner->dwLocalPort << "," << owner->ucRemoteAddr << "," << owner->dwRemotePort <<","<< owner->dwState <<"\n";

        printf("%c\n", owner->ucLocalAddr);

    }

    tcpfile.close();
}

/*Port::GetListOfTcpPorts()

{
    string ApplicationName = "";
    string result = "";
    string aux = "";
    string RemotePort = "";
    DWORD(WINAPI * pGetExtendedTcpTable)(
        PVOID pTcpTable,
        PDWORD pdwSize,
        BOOL bOrder,
        ULONG ulAf,
        TCP_TABLE_CLASS TableClass,
        ULONG Reserved
        );
    MIB_TCPTABLE_OWNER_PID* pTCPInfo;
    MIB_TCPROW_OWNER_PID* owner;
    DWORD size;
    DWORD dwResult;

    //HMODULE hLib = LoadLibrary("iphlpapi.dll");

    //pGetExtendedTcpTable = (DWORD(WINAPI*)(PVOID, PDWORD, BOOL, ULONG, TCP_TABLE_CLASS, ULONG))
        //GetProcAddress(hLib, "GetExtendedTcpTable");

    dwResult = GetExtendedTcpTable(NULL, &size, false, AF_INET, TCP_TABLE_OWNER_PID_LISTENER, 0);
    pTCPInfo = (MIB_TCPTABLE_OWNER_PID*)malloc(size);
    dwResult = pGetExtendedTcpTable(pTCPInfo, &size, false, AF_INET, TCP_TABLE_OWNER_PID_LISTENER, 0);
    for (DWORD dwLoop = 0; dwLoop < pTCPInfo->dwNumEntries; dwLoop++)
    {
        owner = &pTCPInfo->table[dwLoop];
        ApplicationName = GetNameByPID(owner->dwOwningPid); 
        OpenedPort = convertInt(ntohs(owner->dwLocalPort));
        RemotePort = convertInt(ntohs(owner->dwRemotePort));
        aux = "TCP ; " + OpenedPort + ";" + RemotePort + ";" + ApplicationName + "\n";
        result = result + aux;

    }
    return result;
}
*/